1.1. Eсть ли разница между window и document?
Ответ: Да. У JavaScript есть глобальный объект и всё происходит через него. window – тот самый объект, который хранит глобальные переменные, функции, местоположение, историю. Всё находится внутри него, setTimeout, XMLHttpRequest, console и localStorage также являются частью window. Аналогично дело обстоит и с document, который является свойством объекта window и представляет DOM. Все ноды – это часть document, следовательно, вы можете использовать getElementById или addEventListener для document. Но обратите внимание, что этих методов нет в объекте window.
1.2. Вызываются ли document.onload и window.onload одновременно?
window.onload вызывается, когда DOM готов и весь контент, включая картинки, стили, фреймы и т.д. загружен. document.onload вызывается когда дерево DOM выстроено, но до момента, как подгружаются картинки, стили и пр.
2.1. document.designMode переключает режим редактирования для всего документа. Допустимые значения: 'on' и 'off'. В соответствии со спецификацией, это свойство по умолчанию имеет значение 'off'. Firefox следует этому стандарту. В более ранних версии Chrome и IE это свойство по умолчанию имеет значение 'inherit'. Начиная с Chrome 43 значение по умолчанию 'off', а значение 'inherit' более не поддерживается. В IE6-10 значение должно быть указанно с большой буквы ('On' и 'Off') 
Включить режим редактирования для <&ltiframe>:
iframeNode.contentDocument.designMode = 'on';
https://developer.mozilla.org/ru/docs/Web/API/Document/designMode
2.2. Разница между document.body.contentEditable = 'true'; и document.designMode = 'on';
В этом случае они эквивалентны. contentEditable делает элемент, к которому он применяется, и все доступные потоки потомков. designMode делает весь документ доступным для редактирования.
2.3. If the design mode is enabled, the user can edit the entire contents of the document like in a WYSIWYG (What You See Is What You Get) editor. The designMode property is not supported by HTML elements, only the editable state of the entire document can be modified with it.
The contentEditable property is more useful, because it allows content editing for almost all HTML elements. The contentEditable property is supported by all commonly used browsers, but only from version 3 in Firefox. In earlier Firefox versions, the only way to insert editable content into your HTML page is to use an iframe element with designMode = 'on'.
http://help.dottoro.com/ljvqvntb.php
3. confirm
Синтаксис:
result = confirm(question);
confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL.
Результатом будет true при нажатии OK и false – при CANCEL(Esc).
Например:
var isAdmin = confirm('Вы - администратор?');
alert(isAdmin);
Резюме:
alert выводит сообщение.
prompt выводит сообщение и ждёт, пока пользователь введёт текст, а затем возвращает введённое значение или null, если ввод отменён (CANCEL/Esc).
confirm выводит сообщение и ждёт, пока пользователь нажмёт «OK» или «CANCEL» и возвращает true/false.
https://learn.javascript.ru/uibasic
4. Все браузеры, кроме IE8- поддерживают метод window.getSelection(), который возвращает объект, схожий с рассмотренным ранее Range. У этого объекта есть точка начала выделения (anchor) и фокусная точка окончания (focus). Точки могут совпадать.
Рассмотрим свойства и методы объекта Selection:
Свойство anchorNode вернет контейнер, в котором начинается выделение. Замечу, что началом выделения считается та граница, от которой вы начали выделение. То есть, если вы выделяете справа налево, то началом будет именно правая граница. Это правило работает везде, кроме браузера Opera, в котором anchorNode вернет ссылку на узел левого края выделения.
Свойство anchorOffset вернет смещение для начала выделения в пределах контейнера anchorNode.
Свойства focusNode и focusOffset работают аналогично для фокусных точек, то есть точек окончания выделения. Opera и здесь отличилась, возвращает вместо фокусной точки узел правого края выделения.
Свойство rangeCount возвращает число объектов Range, которые входят в полученное выделение. Это свойство полезно при использовании метода addRange.
Метод getRangeAt принимает в качестве аргумента индекс объекта Range и возвращает сам объект. Если rangeCount == 1, то работать будет только getRangeAt(0). Таким образом, мы можем получить объект Range, полностью соответствующий текущему выделению.
Метод collapse сворачивает выделение в точку (каретку). Методу можно передать в качестве первого аргумента узел, в который нужно поместить каретку.
Метод extend принимает в качестве аргументов ссылку на контейнер и смещение (parentNode, offset), и перемещает фокусную точку в это положение.
Метод collapseToStart (collapseToEnd) перемещает фокусную (начальную) границу к начальной (фокусной), тем самым сворачивая выделение в каретку.
Метод selectAllChildren принимает в качестве единственного аргумента ссылку на узел и добавляет всех его потомков в выделение.
Метод addRange принимает в качестве аргумента объект Range и добавляет его в выделение. Таким образом можно увеличить количество объектов Range, число которых нам подскажет свойство rangeCount.
Метод removeRange (removeAllRanges) удаляет переданный (все) объект Range из выделения.
Метод toString вернет текстовое содержимое выделения.
https://learn.javascript.ru/range-textrange-selection
5. document.execCommand()
Когда HTML документ переключен в режим редактирования (document.designMode), для него будет доступен метод execCommand, который предоставляет команды для работы с контентом в редактируемой области. Большинство команд влияют на выделение (bold, italics, и тп.), другие вставляют новые элементы (createLink) или влияют на всю строку (indenting). При использовании contentEditable, вызов execCommand влияет на активный редактируемый элемент.
Синтаксис:
execCommand(String aCommandName, Boolean aShowDefaultUI, String aValueArgument)
Аргументы:
String aCommandName - имя команды
Boolean aShowDefaultUI - нужно ли показать пользовательский интерфейс по умолчанию. Это не реализовано в Mozilla.
String aValueArgument - некоторым командам (например insertimage) также требуется значение аргумента (url картинки). Если аргумент не нужен введите null.
Команды:
backColor
Изменить цвет фона документа. В режиме styleWithCss командой устанавливается цвет фона родительского блока. Необходима передача строкового значения цвета в качестве аргумента. (Internet Explorer таким образом устанавливает цвет фона текста.)
bold
Включает/отключает выделение жирным bold отмеченного текста или начиная с места ввода тескта. (Internet Explorer ипсользует тег <&ltstrong> вместо <&ltb>.)
contentReadOnly
Делает содержимое документа либо неизменяемым либо редактируемым. Требуется передача булевого true/false в качестве аргумента. (Не поддерживается Internet Explorer.)
copy
Копирует выделенное в буфер обмена. Возможность такого поведения отличается от браузера к браузеру и расширяется со временем. Следует проверить таблицу совместимости, чтобы убедиться в возможности использования.
createLink
Создает ссылку из выделения, если таковое имеется. Необходима передача HREF URI в качестве аргумента. URI должен содержать как минимум один символ, допускается пробельный. (Internet Explorer создаст ccылку и без URI.)
cut
Вырезает выделенное и помещает его в буфер обмена. Возможность такого поведения отличается от браузера к браузеру и расширяется со временем. Следует проверить таблицу совместимости, чтобы убедиться в возможности использования.
decreaseFontSize
Добавляет тег <&ltsmall> вокруг выделения или с места ввода текста. (Не поддерживается Internet Explorer.)
delete
Удаляет выделенное.
enableInlineTableEditing
Включает/выключает возможность вставки и удаления строк/столбцов таблицы. (Не поддерживается Internet Explorer.)
enableObjectResizing
Включает/выключает возможность изменения размера картинок и других объектов. (Не поддерживается Internet Explorer.)
fontName
Изменяет название шрифта для выделенного текста или с меств ввода текста. Требует передачи в качестве аргумента наименования шрифта (напр., 'Arial') 
fontSize
Изменяет размер шрифта выделенного текста или с места ввода текста. Требует передачи в качестве аргумента размера шрифта (1-7).
foreColor
Изменяет цвет шрифта выделенного текста или с места ввода текста. Требует передачи в качестве аргумента наименования шрифта.
formatBlock
Добавляет тег HTML-блока вокруг строк, содержащих в себе выделенный текст, заменяя блочный элемент, содержащий такие строки если он существует (в Firefox, BLOCKQUOTE  является исключением - он обернет любой блочный элемент). Требует передачи в качестве аргумента наименования Тега. Теоретически может использоваться любой блочный тег (напр., 'H1', 'P', 'DL', 'BLOCKQUOTE'). (Internet Explorer поддерживает только теги заголовков H1 - H6, ADDRESS и PRE, которые должны также быть заключены в символы < >, как например: '<&ltH1>'.)
forwardDelete
Удаляет символ справа от курсора, так же как при нажатии на клавишу delete.
heading
Добавляет тег заголовка вокруг выделенного текста либо в месте где установлен курсор.
Требует передачи строки имени тега в качестве аргумента. (то есть 'H1', 'H6'). (Не поддерживается в Internet Explorer и Safari)
hiliteColor
Изменяет цвет фона для выделенного текста либо в месте где установлен курсор. Требует передачи цвета в качестве аргумента. UseCSS должен быть включен для работы этой функции. (Не поддерживается в Internet Explorer)
increaseFontSize
Добавляет тег BIG вокруг выделенного текста или на месте курсора. (Не поддерживается в Internet Explorer)
indent
Добавляет отступ в строку в которой расположен курсор (или что-то выделено). В Firefox, если выделение охватывает несколько строк с разными уровнями отступа, будут сдвинуты только строки с наименьшим отступом.
insertBrOnReturn
Добавляет тег <&ltbr> или разбивает текущий элемент на два блока. Не работает в Internet Explorer
insertHorizontalRule
Вставляет горизонтальную линию на месте курсора (удаляет выделение).
insertHTML
Вставляет HTML текст на месте курсора (удаляет выделенный текст). Требует передачи правильной HTML строки как аргумент. (Не поддерживается в Internet Explorer)
insertImage
Вставляет изображение на место курсора (удаляет выделенный текст). Необходимо указывать ссылку на изображение в параметре 'aValueArgument'.  (Internet Explorer может создавать изображения с пустым SRC)
insertOrderedList
Создает пронумерованный список из выбранного или на месте курсора.
insertUnorderedList
Создает список из выбранного или на месте курсора.
insertParagraph
Вставляет параграф вокруг выделения или для текущей строки. (Internet Explorer вставляет параграф в месте курсора и удалаяет выделенный текст)
insertText
Вставляет простой текст в месте курсора или выделения (выделенный текст будет заменен).
italic
Переключает курсив в месте курсора или выделения. (Internet Explorer использует теги <&ltem> вместо <&lti>.)
justifyCenter
Центрирует строку в которой есть выделение или установлен курсор.
justifyFull
Выравнивает строку в которой есть выделение или установлен курсор по ширине.
justifyLeft
Выравнивает строку в которой есть выделение или установлен курсор по левому краю.
justifyRight
Выравнивает строку в которой есть выделение или установлен курсор по правому краю.
outdent
Добавляет выступ для строки в которой расположен курсор (или что-то выделено).
paste
Вставляет данные из буфера обмена в место курсора или выделения (последнее заменяется). Доступ к буферу обмена должен быть включен в файле user.js
redo
Повтор последнего действия. (Если было отменено с помощью undo или ctrl+z)
removeFormat
Очищает форматирование для выделенного.
selectAll
Выделяет всё в редактируемом документе.
strikeThrough
Переключает зачеркивание текста для выделенния или на месте курсора.
subscript
Переключает нижний индекс для выбранного или на месте курсора.
superscript
Переключает верхний индекс для выбранного или на месте курсора.
underline
Переключает подчёркивание для выбранного или на месте курсора.
undo
Отмена последнего действия.
unlink
Удаляет ссылку или якорь для выбранной ссылки/якоря
useCSS 
Переключает режим стилизации HTML и CSS для генерируемой разметки. Может принимать только булевые значения true/false. ПРИИЧАНИЕ: этот аргумент с перевернутой логикой (т.е. false = CSS / true = HTML). (Не поддерживается в Internet Explorer.) Внимание! Эта команда является устаревшей, используйте styleWithCSS.
styleWithCSS
Заменяет команду useCSS. Аргумент работает как ожидалось, т.е. true модифицирует/генерирует атрибуты стиля в разметке, false генерирует элементы форматирования.
Пример:
iframeNode.execCommand('bold'); // Жирный текст
iframeNode.execCommand('undo'); // Отмена последнего действия 
iframeNode.execCommand('insertText', false, 'Lorem ipsum dolor sit amet, consectetur adipisicing elit.'); // Вставка текста
https://developer.mozilla.org/ru/docs/Web/API/Document/execCommand
6. Метод JSON.stringify() преобразует значение JavaScript в строку JSON, возможно с заменой значений, если указана функция замены, или с включением только определённых свойств, если указан массив замены.
Синтаксис:
JSON.stringify(value[, replacer[, space]])
Параметры:
value - Значение, преобразуемое в строку JSON.
replacer - Необязательный - Если является функцией, преобразует значения и свойства по ходу их преобразования в строку; если является массивом, определяет набор свойств, включаемых в объект в окончательной строке.
Подробное описание функции replacer даётся в статье Использование родного объекта JSON руководства по JavaScript.
space - Необязательный - Делает результат красиво отформатированным (расставляя пробелы).
Описание:
Порядок преобразования в строку свойств объектов, не являющихся массивами, не гарантируется. Не полагайтесь на порядок свойств во время преобразования.
Объекты Boolean, Number и String преобразуются в соответствующие примитивные значения, в соответствии с традиционным соглашением о семантике преобразований.
Значение undefined, функция или символ, встреченные во время преобразования, будут либо опущены (если они найдены в объекте), либо превращены в null (если они найдены в массиве).
Все свойства, имеющие ключ в виде символа, будут полностью проигнорированы, даже при использовании функции replacer.
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
7. JSON.parse()
Метод JSON.parse() разбирает строку JSON, возможно с преобразованием получаемого в процессе разбора значения.
Синтаксис:
JSON.parse(text[, reviver])
Параметры
text - Разбираемая строка JSON. Смотрите документацию по объекту JSON для описания синтаксиса JSON.
reviver - Необязательный - Если параметр является функцией, определяет преобразование полученного в процессе разбора значения, прежде, чем оно будет возвращено вызывающей стороне.
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
8. EventTarget.addEventListener()
Метод EventTarget.addEventListener() регистрирует определенный обработчик события, вызванного на EventTarget.
EventTarget должен быть либо существующим элементом в документе, либо Document, либо Window, либо любым другим объектом, который поддерживает события (такой, как XMLHttpRequest).
Синтаксис:
target.addEventListener(type, listener[, options]);
target.addEventListener(type, listener[, useCapture]);
target.addEventListener(type, listener[, useCapture, wantsUntrusted]); // только Gecko/Mozilla 
type - Строка, представляющая тип прослушиваемого события.
listener - Объект, который принимает уведомление, когда событие указанного типа произошло. Это должен быть объект, реализующий интерфейс EventListener или просто функция JavaScript.
options - Необязательный - Объект options, который определяет характеристики объекта, прослушивающего событие. Доступны следующие варианты:
capture:  Boolean указывает, что события этого типа будут отправлены зарегистрированному слушателю listener перед отправкой на EventTarget, расположенный ниже в дереве DOM.
once: Boolean указывает, что слушатель должен быть вызван не более одного раза после добавления. Если true, слушатель автоматически удаляется при вызове.
passive:  Boolean указывает, что слушатель никогда не вызовет preventDefault(). Если все же вызов будет произведен, браузер должен игнорировать его и генерировать консольное предупреждение. Пример Improving scrolling performance with passive listeners
 mozSystemGroup: Boolean указывает, что слушатель должен быть добавлен в системную группу. Доступно только в коде, запущенном в XBL или в расширении Chrome.
useCapture - Необязательный - Если равно true, useCapture указывает, что пользователь желает начать захват. После инициализации захвата все события указанного типа будут отправлены в зарегистрированный listener перед отправкой в какой-либо EventTarget под ним в дереве DOM. События, восходящие вверх по дереву, не будут вызывать слушателей, которым назначено использовать захват. Смотрите DOM Level 3 Events для более детального объяснения. Значение useCapture по умолчанию равно false.
Note: For event listeners attached to the event target; the event is in the target phase, rather than capturing and bubbling phases. Events in the target phase will trigger all listeners on an element regardless of the useCapture parameter.
Note: useCapture became optional only in more recent versions of the major browsers; for example, it was not optional prior to Firefox 6. You should provide this parameter for broadest compatibility.
wantsUntrusted - Если равно true, слушатель будет получать сгенерированные события, посланные со страницы (по умолчанию равно false для chrome и true для обычных веб-страниц). Этот параметр доступен только в Gecko и в основном полезен для использования в аддонах и самом браузере. Смотрите Interaction between privileged and non-privileged pages для примеров использования.
Прежде чем использовать определенное значение в объекте options, рекомендуется убедиться, что браузер пользователя поддерживает его, поскольку это дополнение, которое не все браузеры поддерживали исторически.
https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener
9. Интерфейс EventListener представляет собой объект, который может обработать событие, отправленное объектом EventTarget.
https://developer.mozilla.org/ru/docs/Web/API/EventListener
10. Event
Интерфейс Event представляет собой любое событие, которое происходит в DOM; некоторые из них генерируемые пользователем (клик мышью или нажатие клавиши на клавиатуре), а некоторые - генерируемые API (события, обозначающие завершение процесса анимации, приостановка видео и т.д.). Существует много типов событий, некоторые из них используют интерфейсы, базирующиеся на главном интерфейсе Event. Event содержит общие свойства и методы для всех событий.
Интерфейсы, основанные на EventРаздел
Ниже приведён список интерфейсов, основанных на главном интерфейсе Event, а также указаны ссылки на них в документации MDN API. Заметьте, что имена всех интерфейсов оканчиваются на 'Event'.

AnimationEvent
AudioProcessingEvent
BeforeInputEvent
BeforeUnloadEvent
BlobEvent
ClipboardEvent
CloseEvent
CompositionEvent
CSSFontFaceLoadEvent
CustomEvent
DeviceLightEvent
DeviceMotionEvent
DeviceOrientationEvent
DeviceProximityEvent
DOMTransactionEvent
DragEvent
EditingBeforeInputEvent
ErrorEvent
FetchEvent
FocusEvent
GamepadEvent
HashChangeEvent
IDBVersionChangeEvent
InputEvent
KeyboardEvent
MediaStreamEvent
MessageEvent
MouseEvent
MutationEvent
OfflineAudioCompletionEvent
PageTransitionEvent
PointerEvent
PopStateEvent
ProgressEvent
RelatedEvent
RTCDataChannelEvent
RTCIdentityErrorEvent
RTCIdentityEvent
RTCPeerConnectionIceEvent
SensorEvent
StorageEvent
SVGEvent
SVGZoomEvent
TimeEvent
TouchEvent
TrackEvent
TransitionEvent
UIEvent
UserProximityEvent
WebGLContextEvent
WheelEvent
https://developer.mozilla.org/ru/docs/Web/API/Event"}
11.1.Range
Range – это объект, соответствующий фрагменту документа, который может включать узлы и участки текста из этого документа. Наиболее подробно объект Range описан в спецификации DOM Range (https://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Interface).
Чтобы понять о чем речь, обратимся к самому простому случаю Range, который будет подробно рассмотрен ниже – к выделениям. В приводимом ниже примере выделите несколько слов в предложении. Будет выводиться текстовое содержимое выделяемой области:
Соберем микс из жирности, курсива и ссылки и повыделяем здесь.
Но такие области можно создавать не только с помощью пользовательского выделения, но и из JavaScript-сценария, выполняя с ними определенные манипуляции. Однако, написать простой иллюстрирующий код сразу не выйдет, т.к. есть одно НО – Internet Explorer до версии 9. В Microsoft создали собственную реализацию – объект TextRange. Разберём каждую реализацию по-отдельности.
11.2. DOM-реализация Range (кроме IE8-)
Range состоит из двух граничных точек (boundary-points), соответствующих началу и концу области. Позиция любой граничной точки определяется в документе с помощью двух свойств: узел (node) и смещение (offset).
Контейнером (container) называют узел, содержащий граничную точку. Сам контейнер и все его предки называются родительскими контейнерами (ancestor containers) для граничной точки. Родительский контейнер, включающий обе граничные точки, называют корневым контейнером (root container).
На изображении выше граничные точки выделения лежат в текстовых узлах (#text1 и #text2), которые являются контейнерами. Для левой границы родительскими контейнерами являются #text1, H1, BODY, для правой – #text2, P, BODY. Общий родитель для обоих граничных точек – BODY, этот элемент является корневым контейнером.
Если контейнер является текстовым узлом, то смещение определяется в символах от начала DOM-узла. Если контейнер является элементом (Document, DocumentFragment, Element…), то смещение определяется в дочерних узлах.
Смотрим на иллюстрацию (https://learn.javascript.ru/article/range-textrange-selection/56.gif):
Граничные точки объекта Range s1 лежат в текстовых узлах, поэтому смещение задается в символах от начала узла. Для s2 граничные точки расставлены так, что включают весь абзац <p>Blah xyz</p>, поэтому контейнером является элемент BODY, и смещение считается в позициях дочерних узлов.
Объекты Range создаются с помощью вызова document.createRange(). Объект при этом создается пустой, и граничные точки нужно задать далее его методами setStart и setEnd. Смотрим пример.
Рассмотрим вкратце свойства и методы Range:
Свойство commonAncestorContainer вернет ссылку на наиболее вложенный корневой контейнер.
Свойство startContainer (endContainer) вернет ссылку на контейнер верхней (нижней) граничной точки.
Свойство startOffset (endOffset) вернет смещение для верхней (нижней) граничной точки.
Свойство collapsed вернет true, если граничные точки имеют одинаковые контейнеры и смещение (false в противном случае).
Метод setStart (setEnd) задает контейнер (ссылка на узел) и смещение (целочисленное значение) для соответствующих граничных точек. Пример выше.
Методы setStartBefore, setStartAfter, setEndBefore, setEndAfter принимают в качестве единственного аргумента ссылку на узел и устанавливают граничные точки в соот-ии с естественной границей переданного узла. Например:
Методы selectNode и selectNodeContents позволяют создать объект Range по границам узла, ссылку на который они принимают в качестве единственного аргумента. При использовании selectNode передаваемый узел также войдет в Range, в то время как selectNodeContents создаст объект только из содержимого узла:
Метод collapse объединяет граничные точки объекта Range. В качестве единственного аргумента принимает булево значение (true – для объединения в верхней точке, false – в нижней). По-умолчанию true.
Метод toString вернет текстовое содержимое объекта Range.
Метод cloneContents вернет копию содержимого объекта Range в виде фрагмента документа.
Метод cloneRange вернет копию самого объекта Range.
Метод deleteContents удаляет всё содержимое объекта Range.
Метод detach извлекает текущий объект из DOM, так что на него больше нельзя сослаться.
Метод insertNode принимает в качестве единственного аргумента ссылку на узел (или фрагмент документа) и вставляет его в содержимое объекта Range в начальной точке.
Метод extractContents вырезает содержимое объекта Range и возвращает ссылку на полученный фрагмент документа.
Метод surroundContents помещает всё содержимое текущего объекта Range в новый родительский элемент, ссылка на который принимается в качестве единственного аргумента.
Метод compareBoundaryPoints используется для сравнения граничных точек.
С остальными свойствами и методами поэкспериментируйте сами.
https://learn.javascript.ru/range-textrange-selection
12. Добавление и удаление узлов
Изменение DOM – ключ к созданию «живых» страниц.
В этой главе мы рассмотрим, как создавать новые элементы «на лету» и заполнять их данными.
Создание элемента
Для создания элементов используются следующие методы:
document.createElement(tag)
Создает новый элемент с указанным тегом:
var div = document.createElement('div');
document.createTextNode(text)
Создает новый *текстовый* узел с данным текстом:
var textElem = document.createTextNode('Тут был я');
В нашем случае мы хотим сделать DOM-элемент div, дать ему классы и заполнить текстом:
var div = document.createElement('div');
div.className = "alert alert-success";
div.innerHTML = "<strong>Ура!</strong> Вы прочитали это важное сообщение.";

Удаление узлов: removeChild
Для удаления узла есть два метода:
parentElem.removeChild(elem)
Удаляет elem из списка детей parentElem.
parentElem.replaceChild(newElem, elem)
Среди детей parentElem удаляет elem и вставляет на его место newElem.
Оба этих метода возвращают удаленный узел, то есть elem. Если нужно, его можно вставить в другое место DOM тут же или в будущем.
https://learn.javascript.ru/modifying-document
13. Программно присвоить id элементу
element.id = "unique_id";
Где element - элемент, которому вам нужно присвоить id.
https://javascript.ru/forum/events/4593-kak-programmno-prisvoit-id-ehlementu-div.html
14. Сортировка, метод sort(fn)
Метод sort() сортирует массив на месте. Например:
var arr = [ 1, 2, 15 ];
arr.sort();
alert( arr );  // 1, 15, 2
Порядок стал 1, 15, 2, это точно не сортировка чисел. Почему?
Это произошло потому, что по умолчанию sort сортирует, преобразуя элементы к строке.
Поэтому и порядок у них строковый, ведь "2" > "15".
Свой порядок сортировки
Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.
Внутренний алгоритм функции сортировки умеет сортировать любые массивы – апельсинов, яблок, пользователей, и тех и других и третьих – чего угодно. Но для этого ему нужно знать, как их сравнивать. Эту роль и выполняет fn.
Если эту функцию не указать, то элементы сортируются как строки.
Например, укажем эту функцию явно, отсортируем элементы массива как числа:
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a < b) return -1;
}
var arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15
Обратите внимание, мы передаём в sort() именно саму функцию compareNumeric, без вызова через скобки
Как видно из примера выше, функция, передаваемая sort, должна иметь два аргумента.
Алгоритм сортировки, встроенный в JavaScript, будет передавать ей для сравнения элементы массива. Она должна возвращать:
Положительное значение, если a > b,
Отрицательное значение, если a < b,
Если равны – можно 0, но вообще – не важно, что возвращать, если их взаимный порядок не имеет значения.
https://learn.javascript.ru/array-methods
15. Стрелочные функции
Выражения стрелочных функций имеют более короткий синтаксис по сравнению с функциональными выражениями и лексически привязаны к значению this (но не привязаны к собственному this, arguments, super, или new.target). Стрелочные функции всегда анонимные.
Синтаксис:
(param1, param2, …, paramN) => { statements }
(param1, param2, …, paramN) => expression
// эквивалентно: (param1, param2, …, paramN) => { return expression; }
// Круглые скобки не обязательны для единственного параметра:
(singleParam) => { statements }
singleParam => { statements }
// Функция без параметров нуждается в круглых скобках:
() => { statements }
() => expression 
// Эквивалентно: () => { return expression; }
Расширенный синтаксис:
// Parenthesize the body to return an object literal expression:
params => ({foo: bar})

// Rest parameters and default parameters are supported
(param1, param2, ...rest) => { statements }
(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }

// Destructuring within the parameter list is also supported
var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;
f();  // 6
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions
16. Преобразование типов для примитивов
Система преобразования типов в JavaScript очень проста, но отличается от других языков. Поэтому она часто служит «камнем преткновения» для приходящих из других языков программистов.
Всего есть три преобразования:
Строковое: String(value) – в строковом контексте или при сложении со строкой. Работает очевидным образом.
Численное: Number(value) – в численном контексте, включая унарный плюс +value. Происходит при сравнении разных типов, кроме строгого равенства.
Логическое: Boolean(value) – в логическом контексте, можно также сделать двойным НЕ: !!value.
Точные таблицы преобразований даны выше в этой главе.
Особым случаем является проверка равенства с null и undefined. Они равны друг другу, но не равны чему бы то ни было ещё, этот случай прописан особо в спецификации.
Эта глава описывает преобразование только примитивных значений, объекты разбираются далее.
https://learn.javascript.ru/types-conversion
17. Типы данных: [[Class]], instanceof и утки
Оператор typeof
Мы уже знакомы с простейшим способом – оператором typeof.
Оператор typeof надежно работает с примитивными типами, кроме null, а также с функциями. Он возвращает для них тип в виде строки:
alert( typeof 1 );         // 'number'
alert( typeof true );      // 'boolean'
alert( typeof "Текст" );   // 'string'
alert( typeof undefined ); // 'undefined'
alert( typeof null );      // 'object' (ошибка в языке)
alert( typeof alert );     // 'function'
…Но все объекты, включая массивы и даты для typeof – на одно лицо, они имеют один тип 'object':
alert( typeof {} ); // 'object'
alert( typeof [] ); // 'object'
alert( typeof new Date ); // 'object'
Поэтому различить их при помощи typeof нельзя, и в этом его основной недостаток.
Секретное свойство [[Class]]
Для встроенных объектов есть одна «секретная» возможность узнать их тип, которая связана с методом toString.
Во всех встроенных объектах есть специальное свойство [[Class]], в котором хранится информация о его типе или конструкторе.
Оно взято в квадратные скобки, так как это свойство – внутреннее. Явно получить его нельзя, но можно прочитать его «в обход», воспользовавшись методом toString стандартного объекта Object.
Его внутренняя реализация выводит [[Class]] в небольшом обрамлении, как "[object значение]".
Например:
var toString = {}.toString;
var arr = [1, 2];
alert( toString.call(arr) ); // [object Array]
var date = new Date;
alert( toString.call(date) ); // [object Date]
var user = { name: "Вася" };
alert( toString.call(user) ); // [object Object]
В первой строке мы взяли метод toString, принадлежащий именно стандартному объекту {}. Нам пришлось это сделать, так как у Date и Array – свои собственные методы toString, которые работают иначе.
Затем мы вызываем этот toString в контексте нужного объекта obj, и он возвращает его внутреннее, невидимое другими способами, свойство [[Class]].
Для получения [[Class]] нужна именно внутренняя реализация toString стандартного объекта Object, другая не подойдёт.
К счастью, методы в JavaScript – это всего лишь функции-свойства объекта, которые можно скопировать в переменную и применить на другом объекте через call/apply. Что мы и делаем для {}.toString.
Метод также можно использовать с примитивами:
alert( {}.toString.call(123) ); // [object Number]
alert( {}.toString.call("строка") ); // [object String]
Для большего удобства можно сделать функцию getClass, которая будет возвращать только сам [[Class]]:
function getClass(obj) {
  return {}.toString.call(obj).slice(8, -1);
}
alert( getClass(new Date) ); // Date
alert( getClass([1, 2, 3]) ); // Array
Заметим, что свойство [[Class]] есть и доступно для чтения указанным способом – у всех встроенных объектов. Но его нет у объектов, которые создают наши функции. Точнее, оно есть, но равно всегда "Object".
Например:
function User() {}
var user = new User();
alert( {}.toString.call(user) ); // [object Object], не [object User]
Поэтому узнать тип таким образом можно только для встроенных объектов.
Оператор instanceof
Оператор instanceof позволяет проверить, создан ли объект данной функцией, причём работает для любых функций – как встроенных, так и наших.
function User() {}
var user = new User();
alert( user instanceof User ); // true
Таким образом, instanceof, в отличие от [[Class]] и typeof может помочь выяснить тип для новых объектов, созданных нашими конструкторами.
Заметим, что оператор instanceof – сложнее, чем кажется. Он учитывает наследование, которое мы пока не проходили, но скоро изучим и затем вернёмся к instanceof в главе Проверка класса: "instanceof".
https://learn.javascript.ru/class-instanceof
Итого
Для написания полиморфных (это удобно!) функций нам нужна проверка типов.
Для примитивов с ней отлично справляется оператор typeof.
У него две особенности:
Он считает null объектом, это внутренняя ошибка в языке.
Для функций он возвращает function, по стандарту функция не считается базовым типом, но на практике это удобно и полезно.
Для встроенных объектов мы можем получить тип из скрытого свойства [[Class]], при помощи вызова {}.toString.call(obj).slice(8, -1). Для конструкторов, которые объявлены нами, [[Class]] всегда равно "Object".
Оператор obj instanceof Func проверяет, создан ли объект obj функцией Func, работает для любых конструкторов. Более подробно мы разберём его в главе Проверка класса: "instanceof".
И, наконец, зачастую достаточно проверить не сам тип, а просто наличие нужных свойств или методов. Это называется «утиная типизация».
https://learn.javascript.ru/class-instanceof
18. Разница между объектом Node и элементом Element
A node - это общее имя для любого типа объекта в иерархии DOM. A node может быть одним из встроенных элементов DOM, таких как document или document.body, это может быть тег HTML, указанный в HTML, например <input> или <p>, или это может быть текст node, который создается системой для хранения блока текста внутри другого элемента. Итак, в двух словах, node - любой объект DOM.
An element - это один конкретный тип node, поскольку существует множество других типов узлов (текстовые узлы, узлы комментариев, узлы документа и т.д.).
DOM состоит из иерархии узлов, где каждый node может иметь родительский элемент, список дочерних узлов и nextSibling и previousSibling. Эта структура образует древовидную иерархию. document node будет иметь список дочерних узлов (head node и body node). body node будет иметь список дочерних узлов (элементы верхнего уровня на вашей HTML-странице) и т.д.
Итак, a nodeList представляет собой просто массивный список nodes.
Элемент представляет собой определенный тип node, который может быть непосредственно указан в HTML с тегом HTML и может иметь свойства типа id или class. могут иметь детей и т.д. Существуют другие типы узлов, такие как узлы комментариев, текстовые узлы и т.д.... с различными характеристиками. Каждый node имеет свойство .nodeType, которое сообщает, какой тип node он есть.
Здесь вы можете увидеть различные типы узлов (диаграмма из MDN http://qaru.site/img/cee39e4e83eab8dd8b79abbdc047fbd4.png):
Вы можете видеть, что ELEMENT_NODE - это один конкретный тип node, где свойство nodeType имеет значение 1.
Итак, document.getElementById("test") может возвращать только один node и гарантированно быть элементом (конкретным типом node). Из-за этого он просто возвращает элемент, а не список.
Так как document.getElementsByClassName("para") может возвращать более одного объекта, дизайнеры решили вернуть nodeList, потому что тип данных, который они создали для списка из более чем одного node. Поскольку они могут быть только элементами (только элементы обычно имеют имя класса), технически это nodeList, в котором есть только узлы элемента типа, и дизайнеры могли бы сделать иную коллекцию, которая была elementList, но они решил использовать только один тип коллекции, будь то в нем есть только элементы.
EDIT: HTML5 определяет HTMLCollection, который представляет собой список элементов HTML (а не node, только Elements). Ряд свойств или методов в HTML5 теперь возвращает HTMLCollection. Хотя он очень похож в интерфейсе с nodeList, теперь делается различие в том, что он содержит только элементы, а не любой тип node.
Различие между nodeList и HTMLCollection мало влияет на то, как вы его используете (насколько я могу судить), но дизайнеры HTML5 сделали это различие.
Например, свойство element.children возвращает живой HTMLCollection.
http://qaru.site/questions/42905/difference-between-node-object-and-element-object
19. Array.prototype.push()
Метод push() добавляет один или более элементов в конец массива и возвращает новую длину массива.
Синтаксис
arr.push(element1, ..., elementN)
Параметры
elementN - Элементы, добавляемые в конец массива.
Возвращаемое значение
Новое значение свойства length объекта, для которого был вызван данный метод.
Метод push присоединяет значения к массиву.
Описание
Метод push не является привязанным к типу; этот метод может быть вызван или применён к объектам, напоминающим массив. Метод опирается на свойство length для определения места вставки значений. Если свойство length не может быть преобразовано в число, будет использовать индекс 0. Сюда входит случай несуществования свойства length, в этом случае оно также будет создано.
Единственными родными массивоподобными объектами являются строки, хотя к ним он не может быть применён, поскольку строки являются неизменяемыми.
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/push
20. Array.prototype.concat()
Метод concat() возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов.
Синтаксис
var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])
Параметры
valueN - Массивы и/или значения, соединяемые в новый массив. Смотрите описание ниже.
Возвращаемое значение
Новый экземпляр Array.
Описание
Метод concat создаёт новый массив, состоящий из элементов в объекте, на котором он был вызван, за которыми по порядку следуют, для каждого аргумента, все его элементы (если аргумент является массивом), либо сам аргумент (если он массивом не является).
Метод concat не изменяет данный массив или любой из массивов, переданных в аргументах, а вместо этого возвращает поверхностную копию, содержащую копии тех элементов, что были объединены с исходными массивами. Элементы оригинальных массивов копируются в новый массив по следующим правилам:
Ссылки на объекты (но не фактические объекты): метод concat копирует ссылки на объекты в новый массив. И оригинал, и новый массив ссылаются на один и тот же объект. То есть, если объект по ссылке будет изменён, изменения будут видны и в новом, и в исходном массивах.
Строки, числа и булевы значения (но не объекты String, Number или Boolean): метод concat копирует значения строк и чисел в новый массив.
Примечание: Соединение массивов и/или значений в новый массив оставит соединяемые массивы/значения неизменными. Кроме того, любая операция над новым массивом (если только элемент не является ссылкой) не будет затрагивать исходные массивы и наоборот.
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat
21. Метод HTMLInputElement.setSelectionRange()
https://developer.mozilla.org/ru/docs/Web/API/HTMLInputElement/setSelectionRange
https://code.i-harness.com/ru/docs/dom/htmlinputelement/setselectionrange
22. Программно выбирать текст в контентном HTML-элементе?
http://qaru.site/questions/23923/programmatically-select-text-in-a-contenteditable-html-element
https://stackoverflow.com/questions/6139107/programmatically-select-text-in-a-contenteditable-html-element
Если вы хотите выбрать все содержимое элемента (contenteditable или нет) в Chrome, вот как. Это также будет работать в Firefox, Safari 3+, Opera 9+ (возможно, более ранних версиях) и IE 9. Вы также можете создавать подборки до уровня персонажа. Необходимые API-интерфейсы: DOM Range (текущая спецификация DOM Level 2, см. Также MDN) и Selection, который определяется как часть новой спецификации диапазона (MDN docs).
function selectElementContents(el) {
    var range = document.createRange();
    range.selectNodeContents(el);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
}

var el = document.getElementById("foo");
selectElementContents(el);
23. События в деталях
https://learn.javascript.ru/event-details
23.1. Мышь: клики, кнопка, координаты
https://learn.javascript.ru/mouse-clicks
!!!23.2. Мышь: движение mouseover/out, mouseenter/leave
https://learn.javascript.ru/mousemove-mouseover-mouseout-mouseenter-mouseleave
23.3. Мышь: Drag'n'Drop
https://learn.javascript.ru/drag-and-drop
23.4. Мышь: Drag'n'Drop более глубоко
https://learn.javascript.ru/drag-and-drop-objects
23.5. Мышь: отмена выделения, невыделяемые элементы
window.getSelection().removeAllRanges();
window.getSelection().toString();
https://learn.javascript.ru/unselectable
24. Document.createDocumentFragment()
Создает новый пустой DocumentFragment
var fragment = document.createDocumentFragment();
fragment это ссылка на пустой объект DocumentFragment.
Описание
DocumentFragments являются DOM нодами. Они, при этом, не являются частями основного дерева DOM. Обычно используются для создания фрагмента документа, добавления в него новых элементов/нод, а затем присоединения этого фрагмента к основному дереву. В основном дереве фрагмент буден заменён собственными дочерними элементами.
https://developer.mozilla.org/ru/docs/Web/API/Document/createDocumentFragment
25. Объекты: передача по ссылке, Клонирование объектов
https://learn.javascript.ru/object-reference
26. Как узнать, есть ли элемент в массиве?
var animals = ['dog', 'cat', 'hamster', 'bird', 'fish'];
alert( animals.indexOf( 'dog' ) != -1 );
https://ru.stackoverflow.com/questions/465391/%D0%9A%D0%B0%D0%BA-%D1%83%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%B5%D1%81%D1%82%D1%8C-%D0%BB%D0%B8-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-%D0%B2-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B5
!27.1. Поиск: getElement* и querySelector* и не только
https://learn.javascript.ru/searching-elements-dom
!27.2. Document.querySelector()
https://developer.mozilla.org/ru/docs/Web/API/Document/querySelector
!27.3. Использование querySelectorAll для извлечения прямых детей
http://qaru.site/questions/109492/using-queryselectorall-to-retrieve-direct-children
!27.4 Select all elements with “data-” attribute without using jQuery
https://stackoverflow.com/questions/7084557/select-all-elements-with-data-attribute-without-using-jquery/7084588#7084588
!28. Использование data-* атрибутов
https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Using_data_attributes
!29. NodeList
Объект NodeList — это коллекция узлов, возвращаемая такими методами, как Node.childNodes и document.querySelectorAll.
https://developer.mozilla.org/ru/docs/Web/API/NodeList
30. Свойства Element
https://developer.mozilla.org/ru/docs/Web/API/Element
31.1. classList 
Свойство classList возвращает псевдомассив DOMTokenList, содержащий все классы элемента.
Синтаксис
var elementClasses = elem.classList;
Результат - псевдомассив DOMTokenList, содержащий все классы узла elem
ClassList является геттером. Возвращаемый им объект имеет несколько методов:
add( String [,String] ) - Добавляет элементу указанные классы
remove( String [,String] ) - Удаляет у элемента указанные классы
item ( Number ) - Результат аналогичен вызову сlassList[Number]
toggle ( String [, Boolean])
- Если класс у элемента отсутствует - добавляет, иначе - убирает. Когда вторым параметром передано false - удаляет указанный класс, а если true - добавляет.
- Если вторым параметром передан undefined или переменная с typeof == 'undefined', поведение будет аналогичным передаче только первого параметра при вызове toggle.
contains ( String ) - Проверяет, есть ли данный класс у элемента (вернет true или false)
И, конечно же, у ClassList есть заветное свойство length, которое возвращает количество классов у элемента.
https://developer.mozilla.org/ru/docs/Web/API/Element/classList
31.2. className
Свойство className отвечает за значение атрибута class элемента.
var cName = elem.className;
elem.className = cName;
cName - строка. Если нужно указать несколько классов, они указываются через пробел.
https://developer.mozilla.org/ru/docs/Web/API/Element/className
31.4. DOMTokenList
The DOMTokenList interface represents a set of space-separated tokens. Such a set is returned by Element.classList, HTMLLinkElement.relList, HTMLAnchorElement.relList, HTMLAreaElement.relList, HTMLIframeElement.sandbox, or HTMLOutputElement.htmlFor. It is indexed beginning with 0 as with JavaScript Array objects. DOMTokenList is always case-sensitive.
https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList
31.5. DOMTokenList.contains()
The contains() method of the DOMTokenList interface returns a Boolean — true if the underlying list contains the given token, otherwise false.
Syntax
tokenList.contains(token);
https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList/contains
32. Свойство undefined
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/undefined
33. Объекты: перебор свойств
for (key in obj) {
  /* ... делать что-то с obj[key] ... */
}
https://learn.javascript.ru/object-for-in
34. Конструкция switch
Конструкция switch заменяет собой сразу несколько if.
Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.
Синтаксис:
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
https://learn.javascript.ru/switch
35. Переменные: let и const
https://learn.javascript.ru/let-const
36. Всё вместе: особенности JavaScript
https://learn.javascript.ru/javascript-specials
37. Массив: перебирающие методы
https://learn.javascript.ru/array-iteration
38. Добавление и удаление узлов
https://learn.javascript.ru/modifying-document
39. GlobalEventHandlers.onselectstart
https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onselectstart
40. Типы переменных
https://learn.javascript.ru/types-intro
41. Dict to String
https://stackoverflow.com/questions/5612787/converting-an-object-to-a-string
42. setTimeout и setInterval
https://learn.javascript.ru/settimeout-setinterval#settimeout
43. Количество элементов в объекте javascript
http://qaru.site/questions/44547/number-of-elements-in-a-javascript-object
Object.keys(yourObject).length
44. Функции обратного вызова в JavaScript
https://getinstance.info/articles/javascript/callbacks-in-javascript/
45. Что такое callback-функция в JavaScript?
https://ru.hexlet.io/blog/posts/javascript-what-the-heck-is-a-callback
46. Понимание callback-функций (колбеков)
https://habr.com/ru/post/151716/
47. Как выполнить задержку в Javascript?
https://ru.stackoverflow.com/questions/251150/%D0%9A%D0%B0%D0%BA-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D1%8C-%D0%B7%D0%B0%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D1%83-%D0%B2-javascript
48. Как приостановить выполнение функции в JavaScript?
https://ru.stackoverflow.com/questions/35579/%D0%9A%D0%B0%D0%BA-%D0%BF%D1%80%D0%B8%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D1%8C-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%B2-javascript?rq=1
49. Глобальный объект
https://learn.javascript.ru/global-object
50. Ширина div с абсолютным положением зависит от его родительской ширины?
http://qaru.site/questions/910873/the-width-of-div-with-absolute-position-depends-on-its-parents-width
51. Одновременное нажатие клавиш ctrl alt shift с прочими
document.addEventListener ("keydown", function (zEvent) {
    if (zEvent.ctrlKey  &&  zEvent.altKey  &&  zEvent.key === "e") {  // case sensitive
        // DO YOUR STUFF HERE
    }
} );
https://stackoverflow.com/questions/37557990/detecting-combination-keypresses-control-alt-shift
52. События клавиатуры
https://developer.mozilla.org/ru/docs/Web/API/KeyboardEvent
53. Какая разница между & и && в JavaScript?
http://qaru.site/questions/114245/whats-the-difference-between-and-in-javascript
& побитовое значение AND
Этот оператор ожидает двух чисел и перенастроит число .. Если они не являются числами, они передаются в числа.

Как это работает? У Википедии есть ответ: https://en.wikipedia.org/wiki/Bitwise_operation#AND

Примечание.. В Javascript использование этого оператора обескуражено, поскольку нет целочисленного типа данных, только с плавающей запятой. Таким образом, поплавки преобразуются в целые числа до каждой операции, что замедляет работу. Кроме того, он не имеет реального использования в типичных веб-приложениях и создает нечитаемый код.

Общее правило: Избегайте. Не используйте его. Он редко имеет место в поддерживаемом и читаемом JS-коде.

&& является логическим И
Он ожидает два аргумента и возвращает:

Первый термин, который вычисляет false
Последний термин в противном случае (если все true-y)
Вот несколько примеров:

0 && false          0 (both are false-y, but 0 is the first)
true && false       false (second one is false-y)
true && true        true (both are true-y)
true && 20          20 (both are true-y)
54. Логические операторы
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%D0%9B%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B
55. YOUTUBE PLAYER
HTML: <video tabindex="-1" class="video-stream html5-main-video" controlslist="nodownload" style="width: 1052px; height: 592px; left: 0px; top: 0px;" src="blob:https://www.youtube.com/213ff660-7116-4810-b8af-5cc3c2b3ceda"></video>
CSS: #movie_player > div.html5-video-container > video
56.1. Node​.clone​Node()
https://developer.mozilla.org/ru/docs/Web/API/Node/cloneNode
56.2. Document.importNode()
https://developer.mozilla.org/ru/docs/Web/API/Document/importNode
57. Блокировка прокрутки
https://javascript.ru/forum/misc/32243-kak-zapretit-skroll-dokumenta.html
58. Прозрачность
https://html5book.ru/transparency/
59. Свойство CSS overflow
Свойство overflow управляет отображением содержания блочного элемента, если оно целиком не помещается и выходит за область заданных размеров.
http://htmlbook.ru/css/overflow
60. Как получить размер изображения (высота и ширина) с помощью JavaScript?
http://qaru.site/questions/15058/how-to-get-image-size-height-width-using-javascript
61. margin-top в процентах не работает как ожидалось
http://qaru.site/questions/4420926/margin-top-in-percentage-not-working-as-expected
https://www.internet-technologies.ru/articles/procentnye-znacheniya-dlya-vertikalnyh-svoystv-v-css.html
62. Удалите все дочерние элементы DOM node в JavaScript
http://qaru.site/questions/15609/remove-all-child-elements-of-a-dom-node-in-javascript
63. Очистка памяти при removeChild/innerHTML
https://learn.javascript.ru/memory-removechild-innerhtml
54. Клавиатура: keyup, keydown, keypress
https://learn.javascript.ru/keyboard-events
55. Element: dblclick event
https://developer.mozilla.org/en-US/docs/Web/API/Element/dblclick_event
56. Оператор delete удаляет свойство из объекта.
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/delete
57. Вернуть несколько значений в JavaScript?
http://qaru.site/questions/15356/return-multiple-values-in-javascript
58. Округление
https://learn.javascript.ru/number
59. Метод splice
https://learn.javascript.ru/array-methods#metod-splice
60. Двойной клик ondblclick
https://www.w3schools.com/Jsref/event_ondblclick.asp
61. String.prototype.slice()
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/slice
62. Не использовать this в .forEach(function(){})
63. JavaScript | Array.join() Method
https://www.geeksforgeeks.org/javascript-array-join-method/
64. Атрибут height для таблицы
http://htmlbook.ru/html/table/height
65. Размеры и прокрутка страницы
https://learn.javascript.ru/metrics-window
66. Как заменить текст на CSS?
http://qaru.site/questions/36687/how-can-i-replace-text-with-css
67. Javascript - переход по url с открытием новой вкладки
https://ru.stackoverflow.com/questions/7006/javascript-%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%BE%D0%B4-%D0%BF%D0%BE-url-%D1%81-%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%B8%D0%B5%D0%BC-%D0%BD%D0%BE%D0%B2%D0%BE%D0%B9-%D0%B2%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B8/7007
https://javascript.ru/forum/events/5479-perekhod-po-ssylke-ispolzuya-sobytie.html
68. Переход по ссылке в новое окно
<a href="" target = "_blank"></a>
68. CSS cursor
http://htmlbook.ru/css/cursor
https://developer.mozilla.org/ru/docs/Web/CSS/cursor
69. Дата и Время
https://learn.javascript.ru/datetime
70. Удаление элемента ассоциированного массива (словаря)
http://qaru.site/questions/14818/how-do-i-remove-objects-from-a-javascript-associative-array
71. JavaScript String toUpperCase() Method
https://www.w3schools.com/jsref/jsref_touppercase.asp
72. Прототип объекта
https://learn.javascript.ru/prototype